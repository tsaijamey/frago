"""
Deployment Agent — analyze workspace changes, match local projects, deploy resources.

After `frago sync` pulls remote updates, the Deployment Agent:
  1. Analyzes which workspace resources changed
  2. Matches project workspaces to local project directories
  3. Generates a deployment plan with confidence scores
  4. Executes the plan (copy resources to target locations)

Design principle: no hardcoded registry. The agent discovers local projects
and matches them by canonical ID (git remote URL).
"""

import json
import logging
import subprocess
from dataclasses import dataclass, field
from datetime import UTC, datetime
from pathlib import Path
from typing import Optional

from frago.compat import get_windows_subprocess_kwargs
from frago.tools.workspace import (
    CLAUDE_HOME,
    WORKSPACES_DIR,
    ProjectInfo,
    WorkspaceChanges,
    _discover_projects,
    _encode_project_path,
    _sync_dir,
    _sync_file,
    get_canonical_id,
)

logger = logging.getLogger(__name__)

PENDING_DEPLOYMENTS_FILE = WORKSPACES_DIR / ".pending_deployments.json"


# =============================================================================
# Data Models
# =============================================================================


@dataclass
class DeployAction:
    """A single deployment action."""
    resource: str            # e.g. "CLAUDE.md", "skills/git-linear-history"
    change_type: str         # "added", "modified", "deleted"
    target: str              # target path or "???" if unknown
    action: str              # "deploy", "pending", "skip"
    confidence: float        # 0.0-1.0
    workspace: str = ""      # source workspace name
    git_tracked: bool = False  # whether target .claude/ is git-tracked


@dataclass
class ProjectMatch:
    """Result of matching a workspace canonical ID to a local project."""
    path: Path
    confidence: float  # 1.0 = exact match, 0.5 = fuzzy


@dataclass
class DeploymentPlan:
    """Complete deployment plan generated by the agent."""
    actions: list[DeployAction] = field(default_factory=list)
    created_at: datetime = field(default_factory=lambda: datetime.now(UTC))

    @property
    def has_actionable(self) -> bool:
        return any(a.action == "deploy" for a in self.actions)

    @property
    def has_pending(self) -> bool:
        return any(a.action == "pending" for a in self.actions)

    def to_table_data(self) -> list[dict]:
        """Convert to structured table data for display/messaging."""
        return [
            {
                "resource": a.resource,
                "change_type": a.change_type,
                "target": a.target,
                "action": a.action,
                "confidence": a.confidence,
                "git_tracked": a.git_tracked,
            }
            for a in self.actions
        ]

    def to_dict(self) -> dict:
        """Serialize for persistence."""
        return {
            "actions": self.to_table_data(),
            "created_at": self.created_at.isoformat(),
        }

    @classmethod
    def from_dict(cls, data: dict) -> "DeploymentPlan":
        """Deserialize from persistence."""
        actions = [
            DeployAction(
                resource=a["resource"],
                change_type=a["change_type"],
                target=a["target"],
                action=a["action"],
                confidence=a["confidence"],
                workspace=a.get("workspace", ""),
                git_tracked=a.get("git_tracked", False),
            )
            for a in data.get("actions", [])
        ]
        created_at = datetime.fromisoformat(data["created_at"]) if "created_at" in data else datetime.now(UTC)
        return cls(actions=actions, created_at=created_at)

    def save(self, path: Optional[Path] = None) -> None:
        """Persist deployment plan to disk."""
        target = path or PENDING_DEPLOYMENTS_FILE
        target.parent.mkdir(parents=True, exist_ok=True)
        target.write_text(
            json.dumps(self.to_dict(), indent=2, ensure_ascii=False),
            encoding="utf-8",
        )

    @classmethod
    def load(cls, path: Optional[Path] = None) -> Optional["DeploymentPlan"]:
        """Load pending deployment plan from disk."""
        target = path or PENDING_DEPLOYMENTS_FILE
        if not target.exists():
            return None
        try:
            data = json.loads(target.read_text(encoding="utf-8"))
            return cls.from_dict(data)
        except (json.JSONDecodeError, KeyError, Exception) as e:
            logger.warning("Failed to load deployment plan: %s", e)
            return None

    @classmethod
    def clear_pending(cls, path: Optional[Path] = None) -> None:
        """Remove pending deployment plan file."""
        target = path or PENDING_DEPLOYMENTS_FILE
        if target.exists():
            target.unlink()


# =============================================================================
# Deployment Agent
# =============================================================================


class DeploymentAgent:
    """Analyze workspace changes and generate deployment plans.

    Does NOT depend on a hardcoded registry. Discovers local projects
    by scanning configured roots and matches by canonical ID.
    """

    def __init__(
        self,
        scan_roots: list[str],
        exclude_patterns: list[str],
    ):
        self.scan_roots = scan_roots
        self.exclude_patterns = exclude_patterns
        self._local_projects: Optional[list[ProjectInfo]] = None

    @property
    def local_projects(self) -> list[ProjectInfo]:
        if self._local_projects is None:
            self._local_projects = _discover_projects(
                self.scan_roots, self.exclude_patterns,
            )
        return self._local_projects

    def analyze(self, changes: WorkspaceChanges) -> DeploymentPlan:
        """Analyze workspace changes and generate a deployment plan.

        Groups file-level changes into resource-level actions and determines
        deployment targets.
        """
        # Group changes by (workspace, resource)
        resource_changes: dict[tuple[str, str], str] = {}
        for item in changes.items:
            path_parts = item.path.split("/")
            if len(path_parts) >= 2:
                resource = "/".join(path_parts[:2])
            else:
                resource = item.path

            key = (item.workspace, resource)
            if key not in resource_changes:
                resource_changes[key] = item.change_type
            elif resource_changes[key] != item.change_type:
                resource_changes[key] = "modified"

        actions = []
        for (workspace, resource), change_type in sorted(resource_changes.items()):
            if workspace == "__system__":
                actions.append(DeployAction(
                    resource=resource,
                    change_type=change_type,
                    target=str(CLAUDE_HOME),
                    action="deploy",
                    confidence=1.0,
                    workspace=workspace,
                ))
            else:
                canonical_id = workspace.replace("__", "/")
                match = self._find_local_project(canonical_id)
                if match:
                    git_tracked = self._is_claude_dir_git_tracked(match.path)
                    actions.append(DeployAction(
                        resource=resource,
                        change_type=change_type,
                        target=str(match.path),
                        action="deploy",
                        confidence=match.confidence,
                        workspace=workspace,
                        git_tracked=git_tracked,
                    ))
                else:
                    actions.append(DeployAction(
                        resource=resource,
                        change_type=change_type,
                        target="???",
                        action="pending",
                        confidence=0.0,
                        workspace=workspace,
                    ))

        return DeploymentPlan(actions=actions)

    def _find_local_project(self, canonical_id: str) -> Optional[ProjectMatch]:
        """Match canonical ID to a local project.

        1. Exact match: same git remote URL
        2. Fuzzy match: same repo name but different org (low confidence)
        """
        for proj in self.local_projects:
            proj_id = get_canonical_id(proj.path)
            if proj_id == canonical_id:
                return ProjectMatch(path=proj.path, confidence=1.0)

        # Fuzzy: match by repo name
        target_name = canonical_id.split("/")[-1]
        for proj in self.local_projects:
            if proj.path.name == target_name:
                return ProjectMatch(path=proj.path, confidence=0.5)

        return None

    @staticmethod
    def _is_claude_dir_git_tracked(project_path: Path) -> bool:
        """Check if a project's .claude/ directory is tracked by project git."""
        try:
            result = subprocess.run(
                ["git", "-C", str(project_path), "ls-files", ".claude/"],
                capture_output=True,
                text=True,
                timeout=5,
                **get_windows_subprocess_kwargs(),
            )
            return bool(result.stdout.strip())
        except (subprocess.TimeoutExpired, FileNotFoundError, Exception):
            return False


# =============================================================================
# Deploy Execution
# =============================================================================


def execute_deployment(plan: DeploymentPlan) -> list[str]:
    """Execute a deployment plan — copy resources from workspace to target locations.

    Only executes actions with action="deploy".

    Returns:
        List of human-readable result messages.
    """
    messages = []

    for action in plan.actions:
        if action.action != "deploy":
            continue

        try:
            if action.workspace == "__system__":
                msg = _deploy_system_resource(action)
            else:
                msg = _deploy_project_resource(action)
            if msg:
                messages.append(msg)
        except Exception as e:
            messages.append(f"Failed to deploy {action.resource}: {e}")
            logger.warning("Deploy failed: %s → %s: %s", action.resource, action.target, e)

    # Clear pending deployments after execution
    DeploymentPlan.clear_pending()

    return messages


def _deploy_system_resource(action: DeployAction) -> Optional[str]:
    """Deploy a __system__ workspace resource to ~/.claude/.

    Resources:
      - CLAUDE.md → ~/.claude/CLAUDE.md
      - commands/... → ~/.claude/commands/...
      - skills/... → ~/.claude/skills/...
      - memories/... → reverse-map and deploy to ~/.claude/projects/<encoded>/memory/
    """
    src_base = WORKSPACES_DIR / "__system__"
    resource = action.resource

    if resource == "CLAUDE.md":
        src = src_base / "CLAUDE.md"
        dst = CLAUDE_HOME / "CLAUDE.md"
        if _sync_file(src, dst):
            return f"Deployed CLAUDE.md → {dst}"
        return None

    if resource.startswith(("commands/", "skills/")):
        src = src_base / resource
        dst = CLAUDE_HOME / resource
        synced = (_sync_dir(src, dst) if src.is_dir()
                  else _sync_file(src, dst) if src.is_file()
                  else False)
        if synced:
            return f"Deployed {resource} → {dst}"
        return None

    # memories/<readable_name> — unmapped memories, device-specific path encoding
    # means we can't reverse-map them. They are synced but not deployed.
    return None


def _deploy_project_resource(action: DeployAction) -> Optional[str]:
    """Deploy a project workspace resource to the local project directory.

    Resources:
      - .claude/... → <project_path>/.claude/...
      - .project-memory/ → ~/.claude/projects/<encoded>/memory/
    """
    target_project = Path(action.target)
    if not target_project.exists():
        return f"Skip {action.resource}: target project {target_project} not found"

    src_base = WORKSPACES_DIR / action.workspace
    resource = action.resource

    if resource.startswith(".claude/"):
        src = src_base / resource
        dst = target_project / resource
        synced = (_sync_dir(src, dst) if src.is_dir()
                  else _sync_file(src, dst) if src.is_file()
                  else False)
        if synced:
            suffix = " (git-tracked)" if action.git_tracked else ""
            return f"Deployed {resource} → {dst}{suffix}"
        return None

    if resource.startswith(".project-memory"):
        return _restore_project_memory(action, target_project)

    return None


def _restore_project_memory(
    action: DeployAction,
    target_project: Path,
) -> Optional[str]:
    """Restore project memory from workspace to Claude Code's projects directory.

    Canonical ID → local project path → encode to Claude's format
    → deploy to ~/.claude/projects/<encoded>/memory/
    """
    encoded_path = _encode_project_path(target_project)
    src = WORKSPACES_DIR / action.workspace / ".project-memory"
    dst = CLAUDE_HOME / "projects" / encoded_path / "memory"

    if not src.exists():
        return None

    if _sync_dir(src, dst):
        return f"Restored project memory → {dst}"

    return None


# =============================================================================
# Deployment Plan Table Rendering
# =============================================================================


def format_deployment_table(plan: DeploymentPlan) -> str:
    """Render deployment plan as a human-readable table.

    Returns empty string if no actions.
    """
    if not plan.actions:
        return ""

    lines = ["\nWorkspace Deployment Plan:"]
    lines.append(f"{'Resource':<35} {'Change':<10} {'Target':<30} {'Action':<8}")
    lines.append("─" * 83)

    for a in plan.actions:
        # Shorten target for display
        target = a.target
        if len(target) > 28:
            target = "~/" + str(Path(target).relative_to(Path.home())) if target.startswith(str(Path.home())) else target
        if len(target) > 28:
            target = "..." + target[-25:]

        action_str = a.action
        if a.git_tracked:
            action_str += "*"

        lines.append(f"{a.resource:<35} {a.change_type:<10} {target:<30} {action_str:<8}")

    if any(a.git_tracked for a in plan.actions):
        lines.append("")
        lines.append("  * git-tracked: changes deployed but need manual commit in project repo")

    if any(a.action == "pending" for a in plan.actions):
        lines.append("")
        lines.append("  ? pending: no local project found for this workspace")

    return "\n".join(lines)
