---
description: 从自然语言特性描述创建或更新功能规格说明。
handoffs: 
   - label: 构建技术计划
      agent: speckit.plan
      prompt: 为规格说明创建计划。我正在构建...
   - label: 明确规格说明要求
      agent: speckit.clarify
      prompt: 明确规格说明要求
      send: true
---

## 用户输入

```text
$ARGUMENTS
```

如果用户输入为空则你自动读取 .claude/do.vibing 文档内容。

在继续之前,您**必须**考虑用户输入(如果不为空)。你应该全程使用中文来撰写所有文档内容或代码注释。

## 大纲

用户在触发消息中 `/speckit.specify` 后输入的文本**就是**特性描述。假设在此对话中您始终可以访问它,即使下面 `$ARGUMENTS` 显示为字面值。除非用户提供了空命令,否则不要要求用户重复。

根据该特性描述,执行以下操作:

1. **为分支生成简洁的短名称**(2-4个单词):
    - 分析特性描述并提取最有意义的关键词
    - 创建一个2-4个单词的短名称,能够捕捉特性的本质
    - 尽可能使用动作-名词格式(例如,"add-user-auth"、"fix-payment-bug")
    - 保留技术术语和首字母缩写词(OAuth2、API、JWT等)
    - 保持简洁但足够描述性以便一眼了解特性
    - 示例:
       - "我想添加用户身份验证" → "user-auth"
       - "为API实现OAuth2集成" → "oauth2-api-integration"
       - "创建分析仪表板" → "analytics-dashboard"
       - "修复支付处理超时错误" → "fix-payment-timeout"

2. **在创建新分支之前检查现有分支**:
    
    a. 首先,获取所有远程分支以确保我们拥有最新信息:
         ```bash
         git fetch --all --prune
         ```
    
    b. 为短名称查找所有来源中的最高特性编号:
         - 远程分支: `git ls-remote --heads origin | grep -E 'refs/heads/[0-9]+-<short-name>$'`
         - 本地分支: `git branch | grep -E '^[* ]*[0-9]+-<short-name>$'`
         - 规格说明目录: 检查匹配 `specs/[0-9]+-<short-name>` 的目录
    
    c. 确定下一个可用编号:
         - 从所有三个来源提取所有编号
         - 找到最高编号N
         - 使用N+1作为新分支编号
    
    d. 使用计算出的编号和短名称运行脚本 `.specify/scripts/bash/create-new-feature.sh --json "$ARGUMENTS"`:
         - 传递 `--number N+1` 和 `--short-name "your-short-name"` 以及特性描述
         - Bash示例: `.specify/scripts/bash/create-new-feature.sh --json "$ARGUMENTS" --json --number 5 --short-name "user-auth" "Add user authentication"`
         - PowerShell示例: `.specify/scripts/bash/create-new-feature.sh --json "$ARGUMENTS" -Json -Number 5 -ShortName "user-auth" "Add user authentication"`
    
    **重要**:
    - 检查所有三个来源(远程分支、本地分支、规格说明目录)以找到最高编号
    - 只匹配具有确切短名称模式的分支/目录
    - 如果未找到使用此短名称的现有分支/目录,则从编号1开始
    - 每个特性只能运行此脚本一次
    - JSON在终端中作为输出提供 - 始终参考它以获取您正在查找的实际内容
    - JSON输出将包含BRANCH_NAME和SPEC_FILE路径
    - 对于参数中的单引号,如"I'm Groot",使用转义语法:例如 'I'\''m Groot'(或如果可能使用双引号:"I'm Groot")

3. 加载 `.specify/templates/spec-template.md` 以了解所需的章节。

4. 遵循此执行流程:

      1. 从输入中解析用户描述
          如果为空: 错误 "未提供特性描述"
      2. 从描述中提取关键概念
          识别: 参与者、动作、数据、约束
      3. 对于不清楚的方面:
          - 基于上下文和行业标准做出明智的猜测
          - 仅在以下情况下标记 [NEEDS CLARIFICATION: 具体问题]:
             - 选择显著影响特性范围或用户体验
             - 存在多种合理的解释且具有不同的含义
             - 不存在合理的默认值
          - **限制: 总共最多3个 [NEEDS CLARIFICATION] 标记**
          - 按影响优先级排序明确事项: 范围 > 安全/隐私 > 用户体验 > 技术细节
      4. 填写用户场景和测试章节
          如果没有清晰的用户流程: 错误 "无法确定用户场景"
      5. 生成功能需求
          每个需求必须是可测试的
          对未指定的细节使用合理的默认值(在假设章节中记录假设)
      6. 定义成功标准
          创建可衡量的、技术无关的结果
          包括定量指标(时间、性能、数量)和定性指标(用户满意度、任务完成)
          每个标准必须可验证而无需实现细节
      7. 识别关键实体(如果涉及数据)
      8. 返回: 成功(规格说明已准备好进行规划)

5. 使用模板结构将规格说明写入SPEC_FILE,用从特性描述(参数)派生的具体细节替换占位符,同时保留章节顺序和标题。

6. **规格说明质量验证**: 在编写初始规格说明后,根据质量标准进行验证:

    a. **创建规格说明质量检查清单**: 使用检查清单模板结构在 `FEATURE_DIR/checklists/requirements.md` 生成检查清单文件,包含以下验证项:

         ```markdown
         # 规格说明质量检查清单: [特性名称]
         
         **目的**: 在进行规划之前验证规格说明的完整性和质量
         **创建日期**: [日期]
         **特性**: [链接到spec.md]
         
         ## 内容质量
         
         - [ ] 无实现细节(语言、框架、API)
         - [ ] 聚焦于用户价值和业务需求
         - [ ] 为非技术利益相关者编写
         - [ ] 所有必填章节已完成
         
         ## 需求完整性
         
         - [ ] 不存在 [NEEDS CLARIFICATION] 标记
         - [ ] 需求是可测试和明确的
         - [ ] 成功标准是可衡量的
         - [ ] 成功标准是技术无关的(无实现细节)
         - [ ] 所有验收场景已定义
         - [ ] 已识别边缘情况
         - [ ] 范围边界清晰
         - [ ] 已识别依赖关系和假设
         
         ## 特性就绪度
         
         - [ ] 所有功能需求都有明确的验收标准
         - [ ] 用户场景涵盖主要流程
         - [ ] 特性满足成功标准中定义的可衡量结果
         - [ ] 没有实现细节泄露到规格说明中
         
         ## 备注
         
         - 标记为未完成的项目需要在 `/speckit.clarify` 或 `/speckit.plan` 之前更新规格说明
         ```

    b. **运行验证检查**: 根据每个检查清单项审查规格说明:
         - 对于每个项,确定是通过还是失败
         - 记录发现的具体问题(引用相关规格说明章节)

    c. **处理验证结果**:

         - **如果所有项都通过**: 标记检查清单为完成并继续第6步

         - **如果项失败(不包括 [NEEDS CLARIFICATION])**:
            1. 列出失败项和具体问题
            2. 更新规格说明以解决每个问题
            3. 重新运行验证直到所有项通过(最多3次迭代)
            4. 如果3次迭代后仍然失败,在检查清单备注中记录剩余问题并警告用户

         - **如果 [NEEDS CLARIFICATION] 标记仍然存在**:
            1. 从规格说明中提取所有 [NEEDS CLARIFICATION: ...] 标记
            2. **限制检查**: 如果存在超过3个标记,只保留3个最关键的(按范围/安全/用户体验影响),并对其余部分做出明智猜测
            3. 对于每个需要明确的事项(最多3个),以此格式向用户提供选项:

                ```markdown
                ## 问题 [N]: [主题]
                
                **上下文**: [引用相关规格说明章节]
                
                **我们需要知道的**: [来自 NEEDS CLARIFICATION 标记的具体问题]
                
                **建议的答案**:
                
                | 选项 | 答案 | 影响 |
                |------|------|------|
                | A    | [第一个建议答案] | [这对特性意味着什么] |
                | B    | [第二个建议答案] | [这对特性意味着什么] |
                | C    | [第三个建议答案] | [这对特性意味着什么] |
                | 自定义 | 提供您自己的答案 | [解释如何提供自定义输入] |
                
                **您的选择**: _[等待用户响应]_
                ```

            4. **关键 - 表格格式**: 确保markdown表格格式正确:
                - 使用一致的间距并对齐管道符
                - 每个单元格内容周围应有空格: `| 内容 |` 而不是 `|内容|`
                - 标题分隔符必须至少有3个破折号: `|--------|`
                - 测试表格在markdown预览中正确呈现
            5. 按顺序编号问题(Q1、Q2、Q3 - 总共最多3个)
            6. 在等待响应之前一起展示所有问题
            7. 等待用户回答所有问题的选择(例如,"Q1: A, Q2: 自定义 - [详细信息], Q3: B")
            8. 通过用用户选择或提供的答案替换每个 [NEEDS CLARIFICATION] 标记来更新规格说明
            9. 解决所有明确事项后重新运行验证

    d. **更新检查清单**: 在每次验证迭代后,使用当前通过/失败状态更新检查清单文件

7. 报告完成情况,包括分支名称、规格说明文件路径、检查清单结果以及下一阶段的准备情况(`/speckit.clarify` 或 `/speckit.plan`)。

**注意:** 脚本在写入之前创建并检出新分支并初始化规格说明文件。

## 一般指南

## 快速指南

- 专注于用户**需要什么**和**为什么**。
- 避免如何实现(无技术栈、API、代码结构)。
- 为业务利益相关者而非开发人员编写。
- 不要创建任何嵌入在规格说明中的检查清单。那将是一个单独的命令。

### 章节要求

- **必填章节**: 每个特性都必须完成
- **可选章节**: 仅在与特性相关时包含
- 当章节不适用时,完全删除它(不要留下"N/A")

### 用于AI生成

从用户提示创建此规格说明时:

1. **做出明智的猜测**: 使用上下文、行业标准和常见模式来填补空白
2. **记录假设**: 在假设章节中记录合理的默认值
3. **限制明确事项**: 最多3个 [NEEDS CLARIFICATION] 标记 - 仅用于关键决策:
    - 显著影响特性范围或用户体验
    - 有多种合理的解释且具有不同的含义
    - 缺乏任何合理的默认值
4. **优先排序明确事项**: 范围 > 安全/隐私 > 用户体验 > 技术细节
5. **像测试人员一样思考**: 每个模糊的需求都应该不符合"可测试和明确"的检查清单项
6. **需要明确的常见领域**(仅当不存在合理默认值时):
    - 特性范围和边界(包含/排除特定用例)
    - 用户类型和权限(如果可能存在多种冲突的解释)
    - 安全/合规要求(当在法律/财务上很重要时)

**合理默认值的示例**(不要询问这些):

- 数据保留: 该领域的行业标准实践
- 性能目标: 除非另有说明,否则为标准web/移动应用期望
- 错误处理: 用户友好的消息和适当的回退
- 身份验证方法: web应用的标准基于会话或OAuth2
- 集成模式: 除非另有说明,否则为RESTful API

### 成功标准指南

成功标准必须:

1. **可衡量**: 包含具体指标(时间、百分比、计数、比率)
2. **技术无关**: 不提及框架、语言、数据库或工具
3. **以用户为中心**: 从用户/业务角度描述结果,而不是系统内部
4. **可验证**: 可以在不知道实现细节的情况下进行测试/验证

**好的示例**:

- "用户可以在3分钟内完成结账"
- "系统支持10,000个并发用户"
- "95%的搜索在1秒内返回结果"
- "任务完成率提高40%"

**不好的示例**(以实现为重点):

- "API响应时间低于200ms"(太技术性,使用"用户即时看到结果")
- "数据库可以处理1000 TPS"(实现细节,使用面向用户的指标)
- "React组件高效渲染"(特定于框架)
- "Redis缓存命中率超过80%"(特定于技术)

