---
description: 在任务生成后,对 spec.md、plan.md 和 tasks.md 进行非破坏性的跨制品一致性和质量分析。
---

## 用户输入

```text
$ARGUMENTS
```

在继续之前,您**必须**考虑用户输入(如果不为空)。你应该全程使用中文来撰写所有文档内容或代码注释。

## 目标

在实施之前识别三个核心制品(`spec.md`、`plan.md`、`tasks.md`)之间的不一致、重复、歧义和未充分指定的项目。此命令**必须**仅在 `/speckit.tasks` 成功生成完整的 `tasks.md` 后运行。

## 操作约束

**严格只读**:请**勿**修改任何文件。输出结构化分析报告。提供可选的修复计划(用户必须明确批准后才能手动调用任何后续编辑命令)。

**章程权威**:项目章程(`.specify/memory/constitution.md`)在此分析范围内是**不可协商的**。章程冲突自动为关键问题,需要调整规范、计划或任务——而不是稀释、重新解释或默默忽略原则。如果原则本身需要更改,必须在 `/speckit.analyze` 之外进行单独的明确章程更新。

## 执行步骤

### 1. 初始化分析上下文

从代码仓库根目录运行一次 `.specify/scripts/bash/check-prerequisites.sh --json --require-tasks --include-tasks` 并解析 JSON 以获取 FEATURE_DIR 和 AVAILABLE_DOCS。派生绝对路径:

- SPEC = FEATURE_DIR/spec.md
- PLAN = FEATURE_DIR/plan.md
- TASKS = FEATURE_DIR/tasks.md

如果缺少任何必需文件,则中止并显示错误消息(指示用户运行缺失的先决条件命令)。
对于参数中的单引号,如 "I'm Groot",使用转义语法:例如 'I'\''m Groot'(如果可能,使用双引号:"I'm Groot")。

### 2. 加载制品(渐进式披露)

仅从每个制品加载最少必要的上下文:

**从 spec.md:**

- 概述/上下文
- 功能需求
- 非功能需求
- 用户故事
- 边缘情况(如果存在)

**从 plan.md:**

- 架构/技术栈选择
- 数据模型引用
- 阶段
- 技术约束

**从 tasks.md:**

- 任务 ID
- 描述
- 阶段分组
- 并行标记 [P]
- 引用的文件路径

**从章程:**

- 加载 `.specify/memory/constitution.md` 用于原则验证

### 3. 构建语义模型

创建内部表示(不要在输出中包含原始制品):

- **需求清单**:每个功能和非功能需求都有一个稳定的键(基于祈使短语派生 slug;例如,"用户可以上传文件" → `user-can-upload-file`)
- **用户故事/操作清单**:包含验收标准的离散用户操作
- **任务覆盖映射**:将每个任务映射到一个或多个需求或故事(通过关键字/显式引用模式如 ID 或关键短语推断)
- **章程规则集**:提取原则名称和必须/应该的规范性声明

### 4. 检测流程(令牌高效分析)

专注于高信号发现。限制为总共 50 个发现;在溢出摘要中汇总其余部分。

#### A. 重复检测

- 识别近似重复的需求
- 标记较低质量的措辞以进行合并

#### B. 歧义检测

- 标记缺乏可测量标准的模糊形容词(快速、可扩展、安全、直观、健壮)
- 标记未解决的占位符(TODO、TKTK、???、`<placeholder>` 等)

#### C. 指定不足

- 具有动词但缺少对象或可测量结果的需求
- 缺少验收标准对齐的用户故事
- 引用规范/计划中未定义的文件或组件的任务

#### D. 章程对齐

- 任何与必须原则冲突的需求或计划元素
- 缺少章程规定的部分或质量关卡

#### E. 覆盖差距

- 零关联任务的需求
- 没有映射需求/故事的任务
- 未在任务中反映的非功能需求(例如,性能、安全性)

#### F. 不一致

- 术语漂移(跨文件以不同方式命名的相同概念)
- 计划中引用但规范中缺少的数据实体(反之亦然)
- 任务排序矛盾(例如,没有依赖性注释的情况下,集成任务在基础设置任务之前)
- 冲突的需求(例如,一个需要 Next.js,而另一个指定 Vue)

### 5. 严重性分配

使用此启发式方法对发现进行优先级排序:

- **关键**:违反章程必须项、缺少核心规范制品,或零覆盖率阻止基线功能的需求
- **高**:重复或冲突的需求、模糊的安全/性能属性、不可测试的验收标准
- **中**:术语漂移、缺少非功能任务覆盖、指定不足的边缘情况
- **低**:样式/措辞改进、不影响执行顺序的轻微冗余

### 6. 生成紧凑分析报告

输出 Markdown 报告(不写入文件),结构如下:

## 规范分析报告

| ID | 类别 | 严重性 | 位置 | 摘要 | 建议 |
|----|------|---------|------|------|---------|
| A1 | 重复 | 高 | spec.md:L120-134 | 两个相似的需求... | 合并措辞;保留更清晰的版本 |

(每个发现添加一行;生成以类别首字母为前缀的稳定 ID。)

**覆盖摘要表:**

| 需求键 | 有任务? | 任务 ID | 备注 |
|---------|----------|--------|------|

**章程对齐问题**(如果有):

**未映射任务**(如果有):

**指标:**

- 总需求数
- 总任务数
- 覆盖率 %(具有 >=1 个任务的需求)
- 歧义计数
- 重复计数
- 关键问题计数

### 7. 提供后续操作

在报告末尾,输出简洁的后续操作块:

- 如果存在关键问题:建议在 `/speckit.implement` 之前解决
- 如果只有低/中级问题:用户可以继续,但提供改进建议
- 提供明确的命令建议:例如,"使用细化运行 /speckit.specify","运行 /speckit.plan 调整架构","手动编辑 tasks.md 以添加 'performance-metrics' 的覆盖"

### 8. 提供修复

询问用户:"您希望我为前 N 个问题建议具体的修复编辑吗?"(不要自动应用它们。)

## 操作原则

### 上下文效率

- **最少的高信号令牌**:专注于可操作的发现,而不是详尽的文档
- **渐进式披露**:逐步加载制品;不要将所有内容转储到分析中
- **令牌高效输出**:将发现表限制为 50 行;总结溢出
- **确定性结果**:在没有更改的情况下重新运行应产生一致的 ID 和计数

### 分析指南

- **绝不修改文件**(这是只读分析)
- **绝不臆造缺失的部分**(如果缺少,准确报告)
- **优先处理章程违规**(这些始终是关键问题)
- **使用示例而非详尽规则**(引用具体实例,而非通用模式)
- **优雅地报告零问题**(发出带有覆盖统计信息的成功报告)

## 上下文

$ARGUMENTS

