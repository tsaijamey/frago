---
description: 通过提出最多 5 个高度针对性的澄清问题,识别当前功能规格中未充分说明的领域,并将答案编码回规格文档。
handoffs: 
   - label: 构建技术计划
      agent: speckit.plan
      prompt: 为规格创建计划。我正在构建...
---

## 用户输入

```text
$ARGUMENTS
```

在继续之前,您**必须**考虑用户输入(如果不为空)。你应该全程使用中文来撰写所有文档内容或代码注释。

## 概述

目标:检测并减少活动功能规格中的歧义或缺失的决策点,并直接在规格文件中记录澄清内容。

注意:此澄清工作流预期在调用 `/speckit.plan` **之前**运行(并完成)。如果用户明确表示跳过澄清(例如,探索性尝试),您可以继续,但必须警告下游返工风险增加。

执行步骤:

1. 从代码库根目录**一次性**运行 `.specify/scripts/bash/check-prerequisites.sh --json --paths-only`(组合 `--json --paths-only` 模式 / `-Json -PathsOnly`)。解析最小 JSON 负载字段:
    - `FEATURE_DIR`
    - `FEATURE_SPEC`
    - (可选捕获 `IMPL_PLAN`、`TASKS` 用于未来的链式流程。)
    - 如果 JSON 解析失败,中止并指示用户重新运行 `/speckit.specify` 或验证功能分支环境。
    - 对于参数中的单引号,如 "I'm Groot",使用转义语法:例如 'I'\''m Groot'(或尽可能使用双引号:"I'm Groot")。

2. 加载当前规格文件。使用此分类法执行结构化歧义和覆盖范围扫描。对于每个类别,标记状态:明确 / 部分 / 缺失。生成用于优先级排序的内部覆盖图(除非不会提出问题,否则不输出原始图)。

    功能范围与行为:
    - 核心用户目标和成功标准
    - 明确的超出范围声明
    - 用户角色/人物角色区分

    领域和数据模型:
    - 实体、属性、关系
    - 标识和唯一性规则
    - 生命周期/状态转换
    - 数据量/规模假设

    交互和用户体验流程:
    - 关键用户旅程/序列
    - 错误/空/加载状态
    - 无障碍或本地化说明

    非功能性质量属性:
    - 性能(延迟、吞吐量目标)
    - 可扩展性(水平/垂直、限制)
    - 可靠性和可用性(正常运行时间、恢复预期)
    - 可观察性(日志、指标、跟踪信号)
    - 安全和隐私(身份验证/授权、数据保护、威胁假设)
    - 合规/监管约束(如有)

    集成和外部依赖:
    - 外部服务/API 和故障模式
    - 数据导入/导出格式
    - 协议/版本控制假设

    边缘情况和故障处理:
    - 负面场景
    - 速率限制/节流
    - 冲突解决(例如,并发编辑)

    约束和权衡:
    - 技术约束(语言、存储、托管)
    - 明确的权衡或被拒绝的替代方案

    术语和一致性:
    - 规范术语表术语
    - 避免的同义词/已弃用术语

    完成信号:
    - 验收标准可测试性
    - 可衡量的完成定义风格指标

    其他/占位符:
    - TODO 标记/未解决的决策
    - 缺乏量化的模糊形容词("健壮"、"直观")

    对于状态为部分或缺失的每个类别,添加候选问题机会,除非:
    - 澄清不会实质性改变实现或验证策略
    - 信息最好推迟到规划阶段(内部记录)

3. (内部)生成优先级排序的候选澄清问题队列(最多 5 个)。不要一次性全部输出。应用这些约束:
      - 整个会话总共最多 10 个问题。
      - 每个问题必须可以通过以下任一方式回答:
          - 简短的多项选择(2-5 个不同的、互斥的选项),或
          - 一个单词/短语答案(明确约束:"用 <=5 个词回答")。
      - 仅包括其答案会实质性影响架构、数据建模、任务分解、测试设计、用户体验行为、运营就绪性或合规验证的问题。
      - 确保类别覆盖平衡:尝试首先覆盖最高影响的未解决类别;当单个高影响领域(例如,安全态势)未解决时,避免提出两个低影响问题。
      - 排除已回答的问题、琐碎的风格偏好或计划级执行细节(除非阻碍正确性)。
      - 优先考虑减少下游返工风险或防止验收测试不一致的澄清。
      - 如果超过 5 个类别仍未解决,按(影响 * 不确定性)启发式选择前 5 个。

4. 顺序提问循环(交互式):
      - 每次**仅**提出一个问题。
      - 对于多项选择问题:
          - **分析所有选项**并根据以下条件确定**最合适的选项**:
               - 项目类型的最佳实践
               - 类似实现中的常见模式
               - 风险降低(安全性、性能、可维护性)
               - 与规格中可见的任何明确项目目标或约束的一致性
          - 在顶部突出显示您的**推荐选项**,并提供清晰的理由(1-2 句话解释为什么这是最佳选择)。
          - 格式为:`**推荐:** 选项 [X] - <理由>`
          - 然后将所有选项呈现为 Markdown 表格:

          | 选项 | 描述 |
          |------|------|
          | A | <选项 A 描述> |
          | B | <选项 B 描述> |
          | C | <选项 C 描述>(根据需要添加 D/E,最多 5 个) |
          | 简短 | 提供不同的简短答案(<=5 个词)(仅在自由形式替代方案合适时包含) |

          - 在表格后,添加:`您可以用选项字母回复(例如,"A"),通过说"是"或"推荐"接受推荐,或提供您自己的简短答案。`
      - 对于简短答案风格(没有有意义的离散选项):
          - 根据最佳实践和上下文提供您的**建议答案**。
          - 格式为:`**建议:** <您提出的答案> - <简要理由>`
          - 然后输出:`格式:简短答案(<=5 个词)。您可以通过说"是"或"建议"接受建议,或提供您自己的答案。`
      - 用户回答后:
          - 如果用户回复"是"、"推荐"或"建议",使用您之前陈述的推荐/建议作为答案。
          - 否则,验证答案是否映射到一个选项或符合 <=5 个词的约束。
          - 如果模糊,请求快速消除歧义(计数仍属于同一问题;不要前进)。
          - 一旦满意,将其记录在工作内存中(尚不写入磁盘)并移至下一个排队问题。
      - 在以下情况下停止提问:
          - 所有关键歧义提前解决(剩余排队项变得不必要),或
          - 用户发出完成信号("完成"、"好"、"不再有"),或
          - 您达到 5 个已提问题。
      - 永远不要提前透露未来排队的问题。
      - 如果开始时不存在有效问题,立即报告无关键歧义。

5. 每次接受答案后的集成(增量更新方法):
      - 维护规格的内存表示(开始时加载一次)以及原始文件内容。
      - 对于此会话中第一个集成的答案:
          - 确保存在 `## 澄清` 部分(如果缺失,根据规格模板在最高级别上下文/概述部分之后创建它)。
          - 在其下,为今天创建(如果不存在)`### 会话 YYYY-MM-DD` 子标题。
      - 接受后立即追加项目符号行:`- Q: <问题> → A: <最终答案>`。
      - 然后立即将澄清应用于最合适的部分:
          - 功能歧义 → 更新或在功能需求中添加项目符号。
          - 用户交互/参与者区分 → 使用澄清的角色、约束或场景更新用户故事或参与者子部分(如果存在),保留排序。
          - 数据形状/实体 → 更新数据模型(添加字段、类型、关系),保留排序;简洁地注明添加的约束。
          - 非功能性约束 → 在非功能性/质量属性部分添加/修改可衡量的标准(将模糊形容词转换为指标或明确目标)。
          - 边缘情况/负面流程 → 在边缘情况/错误处理下添加新项目符号(或如果模板提供占位符则创建此类子部分)。
          - 术语冲突 → 在整个规格中规范化术语;仅在必要时保留原始术语,方法是添加一次 `(以前称为"X")`。
      - 如果澄清使较早的模糊陈述无效,替换该陈述而不是重复;不留下过时的矛盾文本。
      - 每次集成后保存规格文件,以最小化上下文丢失的风险(原子覆盖)。
      - 保留格式:不要重新排序无关部分;保持标题层次结构完整。
      - 保持每个插入的澄清最小且可测试(避免叙述偏移)。

6. 验证(在每次写入后执行,加上最终检查):
    - 澄清会话每个接受的答案恰好包含一个项目符号(无重复)。
    - 总共提问(接受)的问题 ≤ 5。
    - 更新的部分不包含新答案本应解决的模糊占位符。
    - 没有矛盾的较早陈述保留(扫描已删除的现在无效的替代选择)。
    - Markdown 结构有效;仅允许新标题:`## 澄清`、`### 会话 YYYY-MM-DD`。
    - 术语一致性:所有更新部分使用相同的规范术语。

7. 将更新的规格写回 `FEATURE_SPEC`。

8. 报告完成(在提问循环结束或提前终止后):
    - 提问和回答的问题数量。
    - 更新的规格路径。
    - 涉及的部分(列出名称)。
    - 覆盖摘要表,列出每个分类类别及状态:已解决(曾为部分/缺失并已解决)、已推迟(超出问题配额或更适合规划)、明确(已经足够)、未解决(仍为部分/缺失但影响低)。
    - 如果仍有任何未解决或已推迟,建议是继续进行 `/speckit.plan` 还是在计划后稍后再次运行 `/speckit.clarify`。
    - 建议的下一个命令。

行为规则:

- 如果未发现有意义的歧义(或所有潜在问题都是低影响的),回复:"未检测到值得正式澄清的关键歧义。"并建议继续。
- 如果规格文件缺失,指示用户首先运行 `/speckit.specify`(不要在此处创建新规格)。
- 永远不要超过 5 个总提问(单个问题的澄清重试不计为新问题)。
- 避免推测性技术栈问题,除非缺少它会阻碍功能清晰度。
- 尊重用户提前终止信号("停止"、"完成"、"继续")。
- 如果由于完全覆盖而未提出问题,输出紧凑的覆盖摘要(所有类别明确),然后建议推进。
- 如果配额已达到且仍有未解决的高影响类别,在已推迟下明确标记它们并说明理由。

优先级排序的上下文:$ARGUMENTS

